import { useEffect, useRef } from 'react';
import { generateNotificationSound, getCurrentNotificationSound, type NotificationSoundType } from '@/components/profile/NotificationSoundSettings';
import { storage } from '@/utils/storage';
import { getSafeAudioContext, canCreateAudioContext } from '@/utils/safeAudioContext';

export const NOTIFICATIONS_ENABLED_KEY = 'notifications-enabled';
export const getNotificationsEnabled = (): boolean => {
  try {
    const v = storage.getItem(NOTIFICATIONS_ENABLED_KEY);
    if (v === null) return true; // ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô: ‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
    return v === 'true';
  } catch {
    return true;
  }
};

interface UseAlertSoundOptions {
  enabled?: boolean;
  playOnce?: boolean; // ‡πÄ‡∏•‡πà‡∏ô‡πÅ‡∏Ñ‡πà‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏ß‡∏ô‡∏•‡∏π‡∏õ
  intervalMs?: number; // ‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà playOnce)
  repeatCount?: number; // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏ó‡∏£‡∏¥‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå (‡∏î‡∏µ‡∏ü‡∏≠‡∏•‡∏ï‡πå 1)
  repeatGapMs?: number; // ‡πÄ‡∏ß‡∏•‡∏≤‡∏û‡∏±‡∏Å‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏£‡∏≠‡∏ö (‡∏´‡∏•‡∏±‡∏á‡∏Ñ‡∏•‡∏¥‡∏õ‡∏à‡∏ö) ‡∏î‡∏µ‡∏ü‡∏≠‡∏•‡∏ï‡πå 1000ms
}

export const useAlertSound = (
  isAlertActive: boolean, 
  options: UseAlertSoundOptions = {}
) => {
  // TEMPORARILY DISABLED FOR iOS PWA COMPATIBILITY
  const { enabled = false, playOnce = true, intervalMs = 5000, repeatCount = 1, repeatGapMs = 1000 } = options;
  const timerRef = useRef<NodeJS.Timeout | null>(null);
  const audioContextRef = useRef<AudioContext | null>(null);
  const userInteractedRef = useRef<boolean>(false);
  const hasPlayedRef = useRef<boolean>(false);
  const currentAudioRef = useRef<HTMLAudioElement | null>(null);
  const audioNodesRef = useRef<Array<{ oscillator: OscillatorNode; gainNode: GainNode }>>([]);
  const cancelChainRef = useRef<{ canceled: boolean }>({ canceled: false });
  const isChainRunningRef = useRef<boolean>(false);
  const instanceIdRef = useRef<string>(`owner_${Math.random().toString(36).slice(2)}_${Date.now()}`);

  // Global playback lock on window to prevent multi-source overlap
  const getGlobalLock = () => {
    const w = window as any;
    if (!w.__alertSoundLock) {
      w.__alertSoundLock = {
        running: false,
        ownerId: null as string | null,
        cancelRef: { canceled: false } as { canceled: boolean },
      };
    }
    return w.__alertSoundLock as {
      running: boolean;
      ownerId: string | null;
      cancelRef: { canceled: boolean };
    };
  };

  // Initialize audio context on user interaction for mobile compatibility
  const initializeAudioContext = async () => {
    try {
      // Use safe AudioContext wrapper
      const audioContext = await getSafeAudioContext();
      if (audioContext) {
        audioContextRef.current = audioContext;
        userInteractedRef.current = true;
        return true;
      }
      return false;
    } catch (error) {
      console.warn('Could not initialize audio context:', error);
      return false;
    }
  };

  // Function to stop all currently playing sounds IMMEDIATELY
  const stopAllSounds = () => {
    // Stop MP3 audio immediately
    if (currentAudioRef.current) {
      currentAudioRef.current.pause();
      currentAudioRef.current.currentTime = 0;
      currentAudioRef.current.src = ''; // Clear source to prevent further loading
      currentAudioRef.current = null;
    }
    
    // Stop Web Audio API nodes with immediate gain reduction
    audioNodesRef.current.forEach(({ oscillator, gainNode }) => {
      try {
        // Immediately cut volume to 0
        gainNode.gain.cancelScheduledValues(audioContextRef.current?.currentTime || 0);
        gainNode.gain.setValueAtTime(0, audioContextRef.current?.currentTime || 0);
        
        // Stop oscillator immediately
        oscillator.stop(audioContextRef.current?.currentTime || 0);
        oscillator.disconnect();
        gainNode.disconnect();
      } catch (error) {
        // Oscillator might already be stopped - ignore error
      }
    });
    audioNodesRef.current = [];
    
    // Global emergency stop - find all audio elements and stop them
    document.querySelectorAll('audio').forEach(audio => {
      audio.pause();
      audio.currentTime = 0;
      audio.src = '';
    });
  };

  // Function to play notification sound using the selected sound preference
  const playNotificationSound = async () => {
    try {
      // Only proceed if we can safely create AudioContext
      if (!canCreateAudioContext()) {
        console.log('‚ö†Ô∏è Cannot play sound - waiting for user interaction');
        return;
      }

      // Ensure audio context is initialized
      const initialized = await initializeAudioContext();
      if (!initialized) {
        console.log('‚ö†Ô∏è AudioContext initialization failed');
        return;
      }

      // Get the user's selected notification sound
      const selectedSound = getCurrentNotificationSound();
      
      // Use the new sound generation system with references for stopping
      // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏±‡∏ö: ‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏∏‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡∏£‡∏≠‡∏ö‡∏ô‡∏µ‡πâ
      stopAllSounds();
      await generateNotificationSound(selectedSound, currentAudioRef, audioNodesRef);
      
    } catch (error) {
      console.warn('Could not play alert sound:', error);
    }
  };

  // Play N times sequentially, waiting for clip end + gap between plays
  const playSequentially = async (times: number) => {
    // Acquire global lock if available
    const lock = getGlobalLock();
    if (lock.running && lock.ownerId !== instanceIdRef.current) {
      // Another instance is already playing; ignore this request
      return;
    }
    lock.running = true;
    lock.ownerId = instanceIdRef.current;
    // Use the global cancelRef so others can cancel if they become owner later
    lock.cancelRef = { canceled: false };
    cancelChainRef.current = lock.cancelRef;
    isChainRunningRef.current = true;
    for (let i = 0; i < times; i++) {
      if (cancelChainRef.current.canceled) break;
      await playNotificationSound();

      // Wait until current audio finished if available
      let waited = false;
      const a = currentAudioRef.current;
      if (a) {
        await new Promise<void>((resolve) => {
          const onEnded = () => {
            a.removeEventListener('ended', onEnded);
            resolve();
          };
          // ‡∏ñ‡πâ‡∏≤ duration ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÅ‡∏•‡∏∞ currentTime ‡πÉ‡∏Å‡∏•‡πâ‡∏à‡∏ö ‡πÉ‡∏´‡πâ‡∏ï‡∏±‡πâ‡∏á timeout ‡πÄ‡∏ú‡∏∑‡πà‡∏≠‡∏Å‡∏£‡∏ì‡∏µ‡πÑ‡∏°‡πà‡∏°‡∏µ ended
          if (!isNaN(a.duration) && isFinite(a.duration)) {
            const remainMs = Math.max(0, (a.duration - a.currentTime) * 1000);
            const t = setTimeout(() => {
              a.removeEventListener('ended', onEnded);
              resolve();
            }, remainMs + 50);
            a.addEventListener('ended', () => {
              clearTimeout(t);
              onEnded();
            }, { once: true });
          } else {
            // ‡πÑ‡∏°‡πà‡∏°‡∏µ duration (‡πÄ‡∏ä‡πà‡∏ô ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢ WebAudio) ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏ú‡∏∑‡πà‡∏≠ 4000ms
            setTimeout(() => resolve(), 4000);
          }
        });
        waited = true;
      } else {
        // ‡πÑ‡∏°‡πà‡∏û‡∏ö audio element ‡πÉ‡∏´‡πâ‡∏£‡∏≠ 4 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÇ‡∏î‡∏¢‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö WebAudio)
        await new Promise((r) => setTimeout(r, 4000));
      }

      if (cancelChainRef.current.canceled) break;
      // Gap ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏£‡∏≠‡∏ö
      await new Promise((r) => setTimeout(r, repeatGapMs));
    }
    isChainRunningRef.current = false;
    // Release global lock only if we are still the owner
    const lock2 = getGlobalLock();
    if (lock2.ownerId === instanceIdRef.current) {
      lock2.running = false;
      lock2.ownerId = null;
    }
  };

  // Set up user interaction listeners for mobile compatibility
  useEffect(() => {
    // Check if AudioContext can be safely used
    if (!canCreateAudioContext()) {
      console.log('üéµ AudioContext not ready - waiting for user interaction');
    }

    const handleUserInteraction = async () => {
      const wasInteracted = userInteractedRef.current;
      if (!wasInteracted) {
        await initializeAudioContext();
      }
      // ‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÇ‡∏ï‡πâ‡∏ï‡∏≠‡∏ö‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ó‡∏µ‡πà active ‡∏≠‡∏¢‡∏π‡πà ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
      if (isAlertActive && enabled && !hasPlayedRef.current && canCreateAudioContext()) {
        try {
          await playNotificationSound();
          hasPlayedRef.current = true;
        } catch {}
      }
    };

    // Add listeners for various user interaction events
    const events = ['click', 'touchstart', 'touchend', 'keydown'];
    events.forEach(event => {
      document.addEventListener(event, handleUserInteraction, { once: true, passive: true });
    });

    return () => {
      events.forEach(event => {
        document.removeEventListener(event, handleUserInteraction);
      });
    };
  }, [isAlertActive, enabled]);

  useEffect(() => {
    // TEMPORARILY DISABLED FOR iOS PWA COMPATIBILITY
    // Only play sound if both alert is active AND notifications are enabled
    if (false && isAlertActive && enabled) {
      // Reset the played flag when alert becomes active
      hasPlayedRef.current = false;
      
      // ‡∏´‡∏≤‡∏Å‡∏°‡∏µ chain ‡∏≠‡∏∑‡πà‡∏ô‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏¢‡∏π‡πà (‡∏à‡∏≤‡∏Å‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏≠‡∏°‡πÇ‡∏û‡πÄ‡∏ô‡∏ô‡∏ï‡πå) ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏° ‡πÑ‡∏°‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ã‡πâ‡∏≠‡∏ô
      const lock = getGlobalLock();
      if (lock.running && lock.ownerId !== instanceIdRef.current) {
        return;
      }
      // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏£‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏à‡πâ‡∏≤‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏° ‡πÉ‡∏´‡πâ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å chain ‡πÄ‡∏î‡∏¥‡∏°‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà
      if (lock.ownerId === instanceIdRef.current) {
        lock.cancelRef.canceled = true;
        stopAllSounds();
      }
      // ‡πÄ‡∏£‡∏¥‡πà‡∏° chain ‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏ö‡∏ö sequential ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡πÅ‡∏•‡∏∞‡∏¢‡∏∂‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡πÅ‡∏ö‡∏ö global
      playSequentially(Math.max(1, repeatCount));
      hasPlayedRef.current = true;
      
      if (playOnce) {
        // Single play mode: just play once and stop
        // No need to set up any timer
      } else {
        // Continuous play mode: set up interval to repeat
        timerRef.current = setInterval(() => {
          playNotificationSound();
        }, intervalMs);
      }
    } else {
      // üö® IMMEDIATE STOP: Clear timer and stop all sounds ASAP
      if (timerRef.current) {
        if (playOnce) {
          clearTimeout(timerRef.current);
        } else {
          clearInterval(timerRef.current);
        }
        timerRef.current = null;
      }
      
      // üîá FORCE STOP: Stop all currently playing sounds immediately
      stopAllSounds();
      
      // Cancel any pending chains immediately
      cancelChainRef.current.canceled = true;
      isChainRunningRef.current = false;
      
      // Reset played flag when alert becomes inactive
      hasPlayedRef.current = false;
      
      // Release global lock if we own it
      const lock = getGlobalLock();
      if (lock.ownerId === instanceIdRef.current) {
        lock.running = false;
        lock.ownerId = null;
        lock.cancelRef.canceled = true;
      }
    }

    // Cleanup on unmount or when effect dependencies change
    return () => {
      // üö® CLEANUP: Stop everything immediately
      if (timerRef.current) {
        if (playOnce) {
          clearTimeout(timerRef.current);
        } else {
          clearInterval(timerRef.current);
        }
        timerRef.current = null;
      }
      
      // Force stop all sounds
      stopAllSounds();
      
      // Cancel chains
      cancelChainRef.current.canceled = true;
      isChainRunningRef.current = false;
      
      // Release global lock
      const lock = getGlobalLock();
      if (lock.ownerId === instanceIdRef.current) {
        lock.running = false;
        lock.ownerId = null;
        lock.cancelRef.canceled = true;
      }
    };
  }, [isAlertActive, enabled, playOnce, intervalMs, repeatCount, repeatGapMs]);

  // Cleanup audio context on unmount
  useEffect(() => {
    return () => {
      // Stop all sounds before closing context
      stopAllSounds();
      
      if (audioContextRef.current) {
        audioContextRef.current.close();
      }
    };
  }, []);
};